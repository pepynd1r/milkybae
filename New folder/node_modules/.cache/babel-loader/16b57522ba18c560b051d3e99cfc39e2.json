{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\development\\\\milkybae\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:\\\\development\\\\milkybae\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldRefreshToken = void 0;\n\nvar react_1 = require(\"react\");\n\nvar config_1 = require(\"../solana/config\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar useChain_1 = __importDefault(require(\"./useChain\"));\n\nvar useRefresh_1 = __importDefault(require(\"./useRefresh\"));\n\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nvar actionCreator_1 = require(\"../actionCreator\");\n\nvar usePOWO_1 = __importDefault(require(\"./usePOWO\"));\n\nvar useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\n\nvar useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\n\nvar shouldRefreshToken = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state, gatewayToken, useWallet, powoRequested) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (gatewayToken) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 2:\n            if (!(gatewayToken.state !== types_1.State.ACTIVE)) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 4:\n            if (!(!useWallet || !useWallet.publicKey || powoRequested)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 6:\n            return _context.abrupt(\"return\", state !== types_1.GatekeeperRecordState.ISSUED);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function shouldRefreshToken(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.shouldRefreshToken = shouldRefreshToken;\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\n\nvar useOrchestration = function useOrchestration(_ref2, state, dispatch) {\n  var wallet = _ref2.wallet,\n      stage = _ref2.stage,\n      chainImplementation = _ref2.chainImplementation,\n      gatekeeperClient = _ref2.gatekeeperClient;\n\n  var _ref3 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n      expectWalletConnected = _ref3.expectWalletConnected;\n\n  var gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage); // Register our hooks here\n\n  var _ref4 = (0, useRefresh_1.default)({\n    stage: stage,\n    gatekeeperClient: gatekeeperClient\n  }, state, dispatch),\n      setRefreshPoll = _ref4.setRefreshPoll,\n      refreshTokenWithProof = _ref4.refreshTokenWithProof;\n\n  var _ref5 = (0, usePOWO_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  }, state, dispatch),\n      waitForConfirmPOWO = _ref5.waitForConfirmPOWO,\n      waitForPOWO = _ref5.waitForPOWO;\n\n  var _ref6 = (0, useGatekeeper_1.default)({\n    wallet: wallet,\n    stage: stage,\n    gatekeeperClient: gatekeeperClient\n  }, state, dispatch),\n      waitForGatekeeperIssuanceRequest = _ref6.waitForGatekeeperIssuanceRequest;\n\n  (0, useGatekeeperRecord_1.default)({\n    wallet: wallet,\n    gatekeeperClient: gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig\n  }, state, dispatch);\n  (0, useChain_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  }, state, dispatch);\n  var gatewayToken = state.gatewayToken,\n      tokenRequested = state.tokenRequested,\n      refreshIntervalId = state.refreshIntervalId,\n      powoRequested = state.powoRequested,\n      refreshInProgress = state.refreshInProgress,\n      walletToRefresh = state.walletToRefresh,\n      civicPass = state.civicPass,\n      refreshTokenState = state.refreshTokenState,\n      gatewayStatus = state.gatewayStatus;\n  /**\n   * Refresh Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * wait until we have a payload that has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  var waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n      logger_1.default.debug('Refresh payload...', refreshPayload);\n\n      if (refreshPayload) {\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  var waitForGatewayToken = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    return new Promise(function (resolve) {\n      logger_1.default.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n      if (gatewayToken) resolve(gatewayToken);\n    });\n  }, [gatewayToken, expectWalletConnected]);\n  var checkRefreshRequired = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connectedWallet) {\n      var useWallet, record, shouldRefresh;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n              // Check preconditions for refresh:\n\n              _context2.next = 3;\n              return waitForGatewayToken();\n\n            case 3:\n              if (gatewayToken) {\n                _context2.next = 5;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 5:\n              _context2.next = 7;\n              return gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n\n            case 7:\n              record = _context2.sent;\n              _context2.next = 10;\n              return (0, exports.shouldRefreshToken)(record.state, gatewayToken, useWallet, powoRequested);\n\n            case 10:\n              shouldRefresh = _context2.sent;\n              dispatch({\n                type: 'getGatekeeperRecord_success',\n                gatekeeperRecord: record\n              });\n\n              if (shouldRefresh) {\n                _context2.next = 17;\n                break;\n              }\n\n              logger_1.default.debug('Refresh not needed. Skipping this attempt.');\n              dispatch({\n                type: 'refresh_complete'\n              });\n              setRefreshPoll(useWallet);\n              return _context2.abrupt(\"return\");\n\n            case 17:\n              logger_1.default.debug('Refresh required. Running the refresh flow.');\n              clearInterval(refreshIntervalId);\n              dispatch({\n                type: 'refresh_start'\n              });\n              dispatch({\n                type: 'civicPass_check_token_status'\n              });\n              dispatch({\n                type: 'refresh_clear_interval'\n              });\n\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x5) {\n      return _ref7.apply(this, arguments);\n    };\n  }(), [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n  /**\n   * Check if the user needs to refresh their roken\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (refreshTokenState === types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n      logger_1.default.debug('Checking if refresh required');\n      checkRefreshRequired();\n    }\n  }, [refreshTokenState]);\n  /**\n   * If the user cancels out of the refresh flow start the refresh interval\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (refreshTokenState === types_1.RefreshTokenState.CANCELLED || refreshTokenState === types_1.RefreshTokenState.FAILED) {\n      logger_1.default.debug('User canceled out of the refresh flow');\n      setRefreshPoll(wallet);\n    }\n  }, [refreshTokenState]);\n  /**\n   * When we have a token start polling to determine the refresh state\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (gatewayStatus === types_1.GatewayStatus.ACTIVE) {\n      logger_1.default.debug('Start polling for the record');\n      setRefreshPoll(wallet);\n    }\n  }, [gatewayStatus]);\n  /**\n   * Issuance Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * poll until a gatekeeper record is found, once active check the chain for a token\n   * then dispatch a tokenChange event that will result in the token getting saved to state\n   * start token refresh polling once a valid token is set\n   */\n\n  var waitForOnChainToken = (0, react_1.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var actionCreator;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!wallet) {\n              _context3.next = 5;\n              break;\n            }\n\n            logger_1.default.debug('waitForOnChainToken');\n            actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n              wallet: wallet,\n              chainImplementation: chainImplementation,\n              gatekeeperClient: gatekeeperClient,\n              dispatch: dispatch\n            });\n            _context3.next = 5;\n            return actionCreator.waitForGatewayToken();\n\n          case 5:\n            return _context3.abrupt(\"return\", null);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })), [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until a presentation request id has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  var waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n      logger_1.default.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  var waitForTokenRequested = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    return new Promise(function (resolve) {\n      logger_1.default.debug('waitForTokenRequested tokenRequested', tokenRequested);\n      if (tokenRequested) resolve(true);\n    });\n  }, [tokenRequested, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  var checkForRequiredProof = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref9) {\n      var requiresProofOfWalletOwnership, payload, result;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              requiresProofOfWalletOwnership = _ref9.requiresProofOfWalletOwnership, payload = _ref9.payload;\n\n              if (!requiresProofOfWalletOwnership) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 4;\n              return waitForConfirmPOWO(payload).then(waitForPOWO);\n\n            case 4:\n              result = _context4.sent;\n              return _context4.abrupt(\"return\", result);\n\n            case 6:\n              return _context4.abrupt(\"return\", {\n                payload: payload\n              });\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x6) {\n      return _ref10.apply(this, arguments);\n    };\n  }(), [waitForConfirmPOWO, waitForPOWO]);\n  /**\n   * New token request flow:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for a gatekeeper record to be created\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (wallet && wallet.publicKey) {\n      logger_1.default.debug('newTokenRequestFlow');\n      waitForTokenRequested().then(waitForCivicPassIssuanceResponsePayload).then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForOnChainToken).then(function () {\n        return setRefreshPoll(wallet);\n      }).catch(function (error) {\n        return logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForTokenRequested, waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken]);\n  /**\n   * Refresh flow:\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to refresh the token\n   * start the polling interval\n   */\n\n  var refreshFlow = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connectedWallet) {\n      var useWallet;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              useWallet = walletToRefresh || connectedWallet; // Do the refresh flow.\n\n              waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshTokenWithProof(useWallet)).then(function () {\n                return setRefreshPoll(useWallet);\n              }).then(function () {\n                dispatch({\n                  type: 'refresh_complete'\n                });\n              }).catch(function (error) {\n                logger_1.default.error('refreshFlow', error);\n                logger_1.default.error('refreshToken error', error);\n                dispatch({\n                  type: 'refresh_complete'\n                });\n                setRefreshPoll(useWallet);\n              });\n\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x7) {\n      return _ref11.apply(this, arguments);\n    };\n  }(), [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, waitForConfirmPOWO, waitForGatewayToken, waitForPOWO, wallet, walletToRefresh, checkForRequiredProof]);\n  /**\n   * Start the refresh flow\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (refreshTokenState === types_1.RefreshTokenState.REQUIRES_POWO) {\n      logger_1.default.debug('Start the refresh flow');\n      refreshFlow(wallet);\n    }\n  }, [wallet, refreshTokenState]);\n};\n\nexports.default = useOrchestration;","map":{"version":3,"sources":["C:/development/milkybae/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useOrchestration.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","shouldRefreshToken","react_1","require","config_1","logger_1","types_1","useChain_1","useRefresh_1","useWalletHooks_1","actionCreator_1","usePOWO_1","useGatekeeper_1","useGatekeeperRecord_1","state","gatewayToken","useWallet","powoRequested","State","ACTIVE","publicKey","GatekeeperRecordState","ISSUED","useOrchestration","dispatch","wallet","stage","chainImplementation","gatekeeperClient","default","expectWalletConnected","gatekeeperEndpoint","getGatekeeperEndpoint","setRefreshPoll","refreshTokenWithProof","waitForConfirmPOWO","waitForPOWO","waitForGatekeeperIssuanceRequest","httpConfig","tokenRequested","refreshIntervalId","refreshInProgress","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","waitForCivicPassRefreshResponsePayload","useCallback","debug","result","Promise","resolve","responsePayload","refreshPayload","CivicPassMessageAction","REFRESH","waitForGatewayToken","checkRefreshRequired","connectedWallet","getGatekeeperRecordWithPayload","owner","record","shouldRefresh","type","gatekeeperRecord","clearInterval","useEffect","RefreshTokenState","CHECK_TOKEN_EXPIRATION","CANCELLED","FAILED","GatewayStatus","waitForOnChainToken","actionCreator","gatewayTokenActionCreator","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","undefined","waitForTokenRequested","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","refreshFlow","REQUIRES_POWO"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldRefreshToken = void 0;\nconst react_1 = require(\"react\");\nconst config_1 = require(\"../solana/config\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst useChain_1 = __importDefault(require(\"./useChain\"));\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst actionCreator_1 = require(\"../actionCreator\");\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nconst shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\n    if (!gatewayToken)\n        return false;\n    if (gatewayToken.state !== types_1.State.ACTIVE)\n        return false;\n    if (!useWallet || !useWallet.publicKey || powoRequested)\n        return false;\n    return state !== types_1.GatekeeperRecordState.ISSUED;\n};\nexports.shouldRefreshToken = shouldRefreshToken;\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage);\n    // Register our hooks here\n    const { setRefreshPoll, refreshTokenWithProof } = (0, useRefresh_1.default)({ stage, gatekeeperClient }, state, dispatch);\n    const { waitForConfirmPOWO, waitForPOWO } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);\n    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig }, state, dispatch);\n    (0, useChain_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const { gatewayToken, tokenRequested, refreshIntervalId, powoRequested, refreshInProgress, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, } = state;\n    /**\n     * Refresh Flows ----------------------------------------------------------------\n     */\n    /**\n     * wait until we have a payload that has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n            logger_1.default.debug('Refresh payload...', refreshPayload);\n            if (refreshPayload) {\n                resolve(refreshPayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForGatewayToken = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n            if (gatewayToken)\n                resolve(gatewayToken);\n        });\n    }, [gatewayToken, expectWalletConnected]);\n    const checkRefreshRequired = (0, react_1.useCallback)(async (connectedWallet) => {\n        const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n        // Check preconditions for refresh:\n        await waitForGatewayToken();\n        if (!gatewayToken)\n            return;\n        const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n        const shouldRefresh = await (0, exports.shouldRefreshToken)(record.state, gatewayToken, useWallet, powoRequested);\n        dispatch({ type: 'getGatekeeperRecord_success', gatekeeperRecord: record });\n        if (!shouldRefresh) {\n            logger_1.default.debug('Refresh not needed. Skipping this attempt.');\n            dispatch({ type: 'refresh_complete' });\n            setRefreshPoll(useWallet);\n            return;\n        }\n        logger_1.default.debug('Refresh required. Running the refresh flow.');\n        clearInterval(refreshIntervalId);\n        dispatch({ type: 'refresh_start' });\n        dispatch({ type: 'civicPass_check_token_status' });\n        dispatch({ type: 'refresh_clear_interval' });\n    }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n    /**\n     * Check if the user needs to refresh their roken\n     */\n    (0, react_1.useEffect)(() => {\n        if (refreshTokenState === types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n            logger_1.default.debug('Checking if refresh required');\n            checkRefreshRequired();\n        }\n    }, [refreshTokenState]);\n    /**\n     * If the user cancels out of the refresh flow start the refresh interval\n     */\n    (0, react_1.useEffect)(() => {\n        if (refreshTokenState === types_1.RefreshTokenState.CANCELLED || refreshTokenState === types_1.RefreshTokenState.FAILED) {\n            logger_1.default.debug('User canceled out of the refresh flow');\n            setRefreshPoll(wallet);\n        }\n    }, [refreshTokenState]);\n    /**\n     * When we have a token start polling to determine the refresh state\n     */\n    (0, react_1.useEffect)(() => {\n        if (gatewayStatus === types_1.GatewayStatus.ACTIVE) {\n            logger_1.default.debug('Start polling for the record');\n            setRefreshPoll(wallet);\n        }\n    }, [gatewayStatus]);\n    /**\n     * Issuance Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until a gatekeeper record is found, once active check the chain for a token\n     * then dispatch a tokenChange event that will result in the token getting saved to state\n     * start token refresh polling once a valid token is set\n     */\n    const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n            });\n            await actionCreator.waitForGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until a presentation request id has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n            logger_1.default.debug('Issuance payload...', issuancePayload);\n            if (issuancePayload !== undefined) {\n                resolve(issuancePayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const waitForTokenRequested = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('waitForTokenRequested tokenRequested', tokenRequested);\n            if (tokenRequested)\n                resolve(true);\n        });\n    }, [tokenRequested, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {\n        if (requiresProofOfWalletOwnership) {\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n            return result;\n        }\n        return { payload };\n    }, [waitForConfirmPOWO, waitForPOWO]);\n    /**\n     * New token request flow:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for a gatekeeper record to be created\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (wallet && wallet.publicKey) {\n            logger_1.default.debug('newTokenRequestFlow');\n            waitForTokenRequested()\n                .then(waitForCivicPassIssuanceResponsePayload)\n                .then(checkForRequiredProof)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForOnChainToken)\n                .then(() => setRefreshPoll(wallet))\n                .catch((error) => logger_1.default.error('ERROR newTokenRequestFlow', error));\n        }\n    }, [\n        waitForTokenRequested,\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n    ]);\n    /**\n     * Refresh flow:\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to refresh the token\n     * start the polling interval\n     */\n    const refreshFlow = (0, react_1.useCallback)(async (connectedWallet) => {\n        const useWallet = walletToRefresh || connectedWallet;\n        // Do the refresh flow.\n        waitForCivicPassRefreshResponsePayload()\n            .then(checkForRequiredProof)\n            .then(refreshTokenWithProof(useWallet))\n            .then(() => setRefreshPoll(useWallet))\n            .then(() => {\n            dispatch({ type: 'refresh_complete' });\n        })\n            .catch((error) => {\n            logger_1.default.error('refreshFlow', error);\n            logger_1.default.error('refreshToken error', error);\n            dispatch({ type: 'refresh_complete' });\n            setRefreshPoll(useWallet);\n        });\n    }, [\n        gatekeeperEndpoint,\n        gatewayToken,\n        powoRequested,\n        refreshInProgress,\n        waitForConfirmPOWO,\n        waitForGatewayToken,\n        waitForPOWO,\n        wallet,\n        walletToRefresh,\n        checkForRequiredProof,\n    ]);\n    /**\n     * Start the refresh flow\n     */\n    (0, react_1.useEffect)(() => {\n        if (refreshTokenState === types_1.RefreshTokenState.REQUIRES_POWO) {\n            logger_1.default.debug('Start the refresh flow');\n            refreshFlow(wallet);\n        }\n    }, [wallet, refreshTokenState]);\n};\nexports.default = useOrchestration;\n"]},"metadata":{},"sourceType":"script"}
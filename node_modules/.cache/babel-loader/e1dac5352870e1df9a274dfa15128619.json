{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\development\\\\milkybae\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:\\\\development\\\\milkybae\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nvar solana_gateway_ts_1 = require(\"@identity.com/solana-gateway-ts\");\n\nvar types_1 = require(\"../types\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar pollForActiveOnChainToken = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(chainImplementation) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, function (onChainToken) {\n              if (!onChainToken) return false; // keep polling\n\n              // keep polling\n              if (onChainToken.state === solana_gateway_ts_1.State.ACTIVE) return true;\n              throw new Error('Token found but not ACTIVE');\n            }, 2000, // wait 2 seconds between retries\n            30 // poll 20 times\n            ));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function pollForActiveOnChainToken(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar GatewayTokenActionCreatorImplementation = function GatewayTokenActionCreatorImplementation(_ref2) {\n  var wallet = _ref2.wallet,\n      chainImplementation = _ref2.chainImplementation,\n      gatekeeperClient = _ref2.gatekeeperClient,\n      dispatch = _ref2.dispatch;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useChain] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useChain] \".concat(message), obj);\n  };\n\n  var isTokenCreated = function isTokenCreated(code) {\n    return code === 200;\n  };\n\n  var isTokenPending = function isTokenPending(code) {\n    return code === 202 || code === 404;\n  };\n\n  var isFailure = function isFailure(code) {\n    return !isTokenPending(code) && code >= 400;\n  };\n\n  var waitForGatewayToken = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var token, state;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return pollForActiveOnChainToken(chainImplementation);\n\n            case 3:\n              token = _context2.sent;\n              logDebug('Result from pollForActiveOnChainToken', token);\n\n              if (token) {\n                _context2.next = 8;\n                break;\n              }\n\n              logError('Token not found onChain');\n              throw new Error('Token not found onChain');\n\n            case 8:\n              dispatch({\n                type: 'tokenChange',\n                token: token\n              });\n              dispatch({\n                type: 'civicPass_check_token_status',\n                token: token\n              });\n              return _context2.abrupt(\"return\");\n\n            case 13:\n              _context2.prev = 13;\n              _context2.t0 = _context2[\"catch\"](0);\n              logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n              _context2.next = 18;\n              return gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n\n            case 18:\n              state = _context2.sent;\n\n              if (!isTokenPending(state)) {\n                _context2.next = 22;\n                break;\n              }\n\n              _context2.next = 22;\n              return waitForGatewayToken();\n\n            case 22:\n              // retries have been exhausted and we still don't have a token\n              // or the gatekeeper threw an error during issuance attempt\n              if (isTokenCreated(state) || isFailure(state)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n                dispatch({\n                  type: 'tokenNotFoundError'\n                });\n              }\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 13]]);\n    }));\n\n    return function waitForGatewayToken() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    waitForGatewayToken: waitForGatewayToken\n  };\n};\n\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;","map":{"version":3,"sources":["C:/development/milkybae/node_modules/@civic/solana-gateway-react/dist/esm/actionCreator/gatewayToken.actionCreator.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GatewayTokenActionCreatorImplementation","solana_gateway_ts_1","require","types_1","logger_1","utils_1","pollForActiveOnChainToken","chainImplementation","pollUntilConditionMet","findGatewayToken","onChainToken","state","State","ACTIVE","Error","wallet","gatekeeperClient","dispatch","logDebug","message","obj","default","debug","logError","error","isTokenCreated","code","isTokenPending","isFailure","waitForGatewayToken","token","type","getGatekeeperStatus","publicKey","GatekeeperRecordState"],"mappings":"AAAA;;;;;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,uCAAR,GAAkD,KAAK,CAAvD;AACA;;AACA,IAAMC,mBAAmB,GAAGC,OAAO,CAAC,iCAAD,CAAnC;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAME,QAAQ,GAAGX,eAAe,CAACS,OAAO,CAAC,WAAD,CAAR,CAAhC;;AACA,IAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMI,yBAAyB;AAAA,sEAAG,iBAAOC,mBAAP;AAAA;AAAA;AAAA;AAAA;AAAA,6CACvB,CAAC,GAAGF,OAAO,CAACG,qBAAZ,EAAmCD,mBAAmB,CAACE,gBAAvD,EAAyE,UAACC,YAAD,EAAkB;AAC9F,kBAAI,CAACA,YAAL,EACI,OAAO,KAAP,CAF0F,CAE5E;;AAAA;AAClB,kBAAIA,YAAY,CAACC,KAAb,KAAuBV,mBAAmB,CAACW,KAApB,CAA0BC,MAArD,EACI,OAAO,IAAP;AACJ,oBAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACH,aANM,EAMJ,IANI,EAME;AACT,cAPO,CAOJ;AAPI,aADuB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAzBR,yBAAyB;AAAA;AAAA;AAAA,GAA/B;;AAWA,IAAMN,uCAAuC,GAAG,SAA1CA,uCAA0C,QAAkE;AAAA,MAA/De,MAA+D,SAA/DA,MAA+D;AAAA,MAAvDR,mBAAuD,SAAvDA,mBAAuD;AAAA,MAAlCS,gBAAkC,SAAlCA,gBAAkC;AAAA,MAAhBC,QAAgB,SAAhBA,QAAgB;;AAC9G,MAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,OAAD;AAAA,QAAUC,GAAV,uEAAgB,IAAhB;AAAA,WAAyBhB,QAAQ,CAACiB,OAAT,CAAiBC,KAAjB,sBAAqCH,OAArC,GAAgDC,GAAhD,CAAzB;AAAA,GAAjB;;AACA,MAAMG,QAAQ,GAAG,SAAXA,QAAW,CAACJ,OAAD;AAAA,QAAUC,GAAV,uEAAgB,IAAhB;AAAA,WAAyBhB,QAAQ,CAACiB,OAAT,CAAiBG,KAAjB,sBAAqCL,OAArC,GAAgDC,GAAhD,CAAzB;AAAA,GAAjB;;AACA,MAAMK,cAAc,GAAG,SAAjBA,cAAiB,CAACC,IAAD;AAAA,WAAUA,IAAI,KAAK,GAAnB;AAAA,GAAvB;;AACA,MAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACD,IAAD;AAAA,WAAUA,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,GAAnC;AAAA,GAAvB;;AACA,MAAME,SAAS,GAAG,SAAZA,SAAY,CAACF,IAAD;AAAA,WAAU,CAACC,cAAc,CAACD,IAAD,CAAf,IAAyBA,IAAI,IAAI,GAA3C;AAAA,GAAlB;;AACA,MAAMG,mBAAmB;AAAA,yEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAIAvB,yBAAyB,CAACC,mBAAD,CAJzB;;AAAA;AAIduB,cAAAA,KAJc;AAKpBZ,cAAAA,QAAQ,CAAC,uCAAD,EAA0CY,KAA1C,CAAR;;AALoB,kBAMfA,KANe;AAAA;AAAA;AAAA;;AAOhBP,cAAAA,QAAQ,CAAC,yBAAD,CAAR;AAPgB,oBAQV,IAAIT,KAAJ,CAAU,yBAAV,CARU;;AAAA;AAUpBG,cAAAA,QAAQ,CAAC;AAAEc,gBAAAA,IAAI,EAAE,aAAR;AAAuBD,gBAAAA,KAAK,EAALA;AAAvB,eAAD,CAAR;AACAb,cAAAA,QAAQ,CAAC;AAAEc,gBAAAA,IAAI,EAAE,8BAAR;AAAwCD,gBAAAA,KAAK,EAALA;AAAxC,eAAD,CAAR;AAXoB;;AAAA;AAAA;AAAA;AAepBP,cAAAA,QAAQ,CAAC,iEAAD,CAAR;AAfoB;AAAA,qBAgBAP,gBAAgB,GAAGgB,mBAAnB,CAAuCjB,MAAM,CAACkB,SAA9C,CAhBA;;AAAA;AAgBdtB,cAAAA,KAhBc;;AAAA,mBAkBhBgB,cAAc,CAAChB,KAAD,CAlBE;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAmBVkB,mBAAmB,EAnBT;;AAAA;AAqBpB;AACA;AACA,kBAAIJ,cAAc,CAACd,KAAD,CAAd,IAAyBiB,SAAS,CAACjB,KAAD,CAAtC,EAA+C;AAC3CY,gBAAAA,QAAQ,CAAC,0DAAD,EAA6DpB,OAAO,CAAC+B,qBAAR,CAA8BvB,KAA9B,CAA7D,CAAR;AACAM,gBAAAA,QAAQ,CAAC;AAAEc,kBAAAA,IAAI,EAAE;AAAR,iBAAD,CAAR;AACH;;AA1BmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAH;;AAAA,oBAAnBF,mBAAmB;AAAA;AAAA;AAAA,KAAzB;;AA6BA,SAAO;AAAEA,IAAAA,mBAAmB,EAAnBA;AAAF,GAAP;AACH,CApCD;;AAqCA/B,OAAO,CAACE,uCAAR,GAAkDA,uCAAlD","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst solana_gateway_ts_1 = require(\"@identity.com/solana-gateway-ts\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst utils_1 = require(\"./utils\");\nconst pollForActiveOnChainToken = async (chainImplementation) => {\n    return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n        if (!onChainToken)\n            return false; // keep polling\n        if (onChainToken.state === solana_gateway_ts_1.State.ACTIVE)\n            return true;\n        throw new Error('Token found but not ACTIVE');\n    }, 2000, // wait 2 seconds between retries\n    30 // poll 20 times\n    );\n};\nconst GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, }) => {\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const isTokenCreated = (code) => code === 200;\n    const isTokenPending = (code) => code === 202 || code === 404;\n    const isFailure = (code) => !isTokenPending(code) && code >= 400;\n    const waitForGatewayToken = async () => {\n        // poll the gatekeeper until we have a status for a created record\n        // if we don't get a created token, then we consider it a failure\n        try {\n            const token = await pollForActiveOnChainToken(chainImplementation);\n            logDebug('Result from pollForActiveOnChainToken', token);\n            if (!token) {\n                logError('Token not found onChain');\n                throw new Error('Token not found onChain');\n            }\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n            return;\n        }\n        catch (error) {\n            logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n            const state = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n            // if the token is still pending or in review then keep polling on-chain\n            if (isTokenPending(state)) {\n                await waitForGatewayToken();\n            }\n            // retries have been exhausted and we still don't have a token\n            // or the gatekeeper threw an error during issuance attempt\n            if (isTokenCreated(state) || isFailure(state)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n                dispatch({ type: 'tokenNotFoundError' });\n            }\n        }\n    };\n    return { waitForGatewayToken };\n};\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nvar react_1 = require(\"react\");\n\nvar utils_1 = require(\"../useReducer/utils\");\n\nvar config_1 = require(\"../config\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          refreshIntervalId: action.refreshIntervalId,\n          walletToRefresh: action.walletToRefresh,\n          refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION\n        });\n      }\n\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED,\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken)\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.COLLECTING_USER_INFORMATION\n        });\n      }\n\n    case 'refresh_clear_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: undefined\n      });\n\n    case 'refresh_set_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: action.refreshIntervalId\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n      gatekeeperClient = _ref.gatekeeperClient;\n  var refreshIntervalId = state.refreshIntervalId,\n      gatewayToken = state.gatewayToken;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useRefresh] \".concat(message), obj);\n  };\n  /**\n   * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n   * event, triggering the refreshFlow\n   */\n\n\n  var setRefreshPoll = (0, react_1.useCallback)(function (connectedWallet) {\n    if (!refreshIntervalId) {\n      var interval = setInterval(function () {\n        dispatch({\n          type: 'refresh_status_check',\n          refreshIntervalId: interval,\n          walletToRefresh: connectedWallet\n        });\n      }, (0, config_1.getRefreshIntervalMs)(stage)); // this will be cleared on completion\n      // We need to know that the interval was set even if it has not fired yet.\n      // to avoid setting duplicate intervals.\n\n      dispatch({\n        type: 'refresh_set_interval',\n        refreshIntervalId: interval\n      });\n      logger_1.default.debug('setRefreshPoll setInterval', (0, config_1.getRefreshIntervalMs)(stage));\n    }\n  }, [refreshIntervalId, stage]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  var refreshTokenWithProof = (0, react_1.useCallback)(function (useWallet) {\n    return function (_ref2) {\n      var proof = _ref2.proof,\n          payload = _ref2.payload;\n      return new Promise(function (resolve, reject) {\n        logDebug('Refresh token with proof', proof);\n\n        if (proof && gatewayToken) {\n          dispatch({\n            type: 'refresh_with_powo_in_progress'\n          });\n          gatekeeperClient().refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload).then(function () {\n            resolve();\n          }).catch(function (error) {\n            logError('Error refreshing token with proof', error);\n            reject(error);\n          });\n        }\n      });\n    };\n  }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n  return {\n    setRefreshPoll: setRefreshPoll,\n    refreshTokenWithProof: refreshTokenWithProof\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"sources":["C:/development/milkybae/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","config_1","logger_1","types_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","refreshIntervalId","walletToRefresh","refreshTokenState","RefreshTokenState","CHECK_TOKEN_EXPIRATION","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","renderIframe","iframeMinimized","COLLECTING_USER_INFORMATION","useRefresh","dispatch","stage","gatekeeperClient","logDebug","message","obj","default","debug","logError","error","setRefreshPoll","useCallback","connectedWallet","interval","setInterval","getRefreshIntervalMs","refreshTokenWithProof","useWallet","proof","payload","Promise","resolve","reject","refreshToken","identifier","publicKey","then","catch"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,IAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAxB;;AACA,IAAMG,QAAQ,GAAGZ,eAAe,CAACS,OAAO,CAAC,WAAD,CAAR,CAAhC;;AACA,IAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMF,OAAO,GAAG,SAAVA,OAAU,CAACO,KAAD,EAAQC,MAAR,EAAmB;AAC/B,UAAQA,MAAM,CAACC,IAAf;AACI,SAAK,sBAAL;AAA6B;AACzB,eAAOb,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAEI,UAAAA,oBAAoB,EAAE,KAAxB;AAA+BC,UAAAA,YAAY,EAAE,KAA7C;AAAoDC,UAAAA,aAAa,EAAEC,SAAnE;AAA8EC,UAAAA,iBAAiB,EAAE,IAAjG;AAAuGC,UAAAA,iBAAiB,EAAER,MAAM,CAACQ,iBAAjI;AAAoJC,UAAAA,eAAe,EAAET,MAAM,CAACS,eAA5K;AAA6LC,UAAAA,iBAAiB,EAAEZ,OAAO,CAACa,iBAAR,CAA0BC;AAA1O,SAAxC,CAAP;AACH;;AACD,SAAK,eAAL;AAAsB;AAClB,eAAOxB,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAEc,UAAAA,aAAa,EAAEf,OAAO,CAACgB,aAAR,CAAsBC,sBAAvC;AAA+DL,UAAAA,iBAAiB,EAAEZ,OAAO,CAACa,iBAAR,CAA0BK;AAA5G,SAAxC,CAAP;AACH;;AACD,SAAK,kBAAL;AAAyB;AACrB,eAAO5B,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAEW,UAAAA,iBAAiB,EAAEZ,OAAO,CAACa,iBAAR,CAA0BM,SAA/C;AAA0DJ,UAAAA,aAAa,EAAE,CAAC,GAAGlB,OAAO,CAACuB,eAAZ,EAA6BnB,KAA7B,EAAoCA,KAAK,CAACoB,YAA1C;AAAzE,SAAxC,CAAP;AACH;;AACD,SAAK,+BAAL;AAAsC;AAClC,eAAO/B,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAEqB,UAAAA,YAAY,EAAE,KAAhB;AAAuBC,UAAAA,eAAe,EAAE,IAAxC;AAA8CR,UAAAA,aAAa,EAAEf,OAAO,CAACgB,aAAR,CAAsBQ;AAAnF,SAAxC,CAAP;AACH;;AACD,SAAK,wBAAL;AACI,aAAOlC,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAES,QAAAA,iBAAiB,EAAEF;AAArB,OAAxC,CAAP;;AACJ,SAAK,sBAAL;AACI,aAAOlB,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACc,MAAP,CAAc,EAAd,EAAkBH,KAAlB,CAAd,EAAwC;AAAES,QAAAA,iBAAiB,EAAER,MAAM,CAACQ;AAA5B,OAAxC,CAAP;;AACJ;AACI,aAAOT,KAAP;AAlBR;AAoBH,CArBD;;AAsBAT,OAAO,CAACE,OAAR,GAAkBA,OAAlB;;AACA,IAAM+B,UAAU,GAAG,SAAbA,UAAa,OAA8BxB,KAA9B,EAAqCyB,QAArC,EAAkD;AAAA,MAA/CC,KAA+C,QAA/CA,KAA+C;AAAA,MAAxCC,gBAAwC,QAAxCA,gBAAwC;AACjE,MAAQlB,iBAAR,GAA4CT,KAA5C,CAAQS,iBAAR;AAAA,MAA2BW,YAA3B,GAA4CpB,KAA5C,CAA2BoB,YAA3B;;AACA,MAAMQ,QAAQ,GAAG,SAAXA,QAAW,CAACC,OAAD;AAAA,QAAUC,GAAV,uEAAgB,IAAhB;AAAA,WAAyBhC,QAAQ,CAACiC,OAAT,CAAiBC,KAAjB,wBAAuCH,OAAvC,GAAkDC,GAAlD,CAAzB;AAAA,GAAjB;;AACA,MAAMG,QAAQ,GAAG,SAAXA,QAAW,CAACJ,OAAD;AAAA,QAAUC,GAAV,uEAAgB,IAAhB;AAAA,WAAyBhC,QAAQ,CAACiC,OAAT,CAAiBG,KAAjB,wBAAuCL,OAAvC,GAAkDC,GAAlD,CAAzB;AAAA,GAAjB;AACA;AACJ;AACA;AACA;;;AACI,MAAMK,cAAc,GAAG,CAAC,GAAGzC,OAAO,CAAC0C,WAAZ,EAAyB,UAACC,eAAD,EAAqB;AACjE,QAAI,CAAC5B,iBAAL,EAAwB;AACpB,UAAM6B,QAAQ,GAAGC,WAAW,CAAC,YAAM;AAC/Bd,QAAAA,QAAQ,CAAC;AACLvB,UAAAA,IAAI,EAAE,sBADD;AAELO,UAAAA,iBAAiB,EAAE6B,QAFd;AAGL5B,UAAAA,eAAe,EAAE2B;AAHZ,SAAD,CAAR;AAKH,OAN2B,EAMzB,CAAC,GAAGxC,QAAQ,CAAC2C,oBAAb,EAAmCd,KAAnC,CANyB,CAA5B,CADoB,CAO2B;AAC/C;AACA;;AACAD,MAAAA,QAAQ,CAAC;AACLvB,QAAAA,IAAI,EAAE,sBADD;AAELO,QAAAA,iBAAiB,EAAE6B;AAFd,OAAD,CAAR;AAIAxC,MAAAA,QAAQ,CAACiC,OAAT,CAAiBC,KAAjB,CAAuB,4BAAvB,EAAqD,CAAC,GAAGnC,QAAQ,CAAC2C,oBAAb,EAAmCd,KAAnC,CAArD;AACH;AACJ,GAjBsB,EAiBpB,CAACjB,iBAAD,EAAoBiB,KAApB,CAjBoB,CAAvB;AAkBA;AACJ;AACA;AACA;AACA;AACA;;AACI,MAAMe,qBAAqB,GAAG,CAAC,GAAG/C,OAAO,CAAC0C,WAAZ,EAAyB,UAACM,SAAD;AAAA,WAAe,iBAAwB;AAAA,UAArBC,KAAqB,SAArBA,KAAqB;AAAA,UAAdC,OAAc,SAAdA,OAAc;AAC1F,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpCnB,QAAAA,QAAQ,CAAC,0BAAD,EAA6Be,KAA7B,CAAR;;AACA,YAAIA,KAAK,IAAIvB,YAAb,EAA2B;AACvBK,UAAAA,QAAQ,CAAC;AAAEvB,YAAAA,IAAI,EAAE;AAAR,WAAD,CAAR;AACAyB,UAAAA,gBAAgB,GACXqB,YADL,CACkB5B,YAAY,CAAC6B,UAD/B,EAC2CP,SAAS,CAACQ,SADrD,EACgEP,KADhE,EACuEC,OADvE,EAEKO,IAFL,CAEU,YAAM;AACZL,YAAAA,OAAO;AACV,WAJD,EAKKM,KALL,CAKW,UAAClB,KAAD,EAAW;AAClBD,YAAAA,QAAQ,CAAC,mCAAD,EAAsCC,KAAtC,CAAR;AACAa,YAAAA,MAAM,CAACb,KAAD,CAAN;AACH,WARD;AASH;AACJ,OAdM,CAAP;AAeH,KAhBsD;AAAA,GAAzB,EAgB3B,CAACd,YAAD,EAAeO,gBAAf,EAAiCQ,cAAjC,CAhB2B,CAA9B;AAiBA,SAAO;AACHA,IAAAA,cAAc,EAAdA,cADG;AAEHM,IAAAA,qBAAqB,EAArBA;AAFG,GAAP;AAIH,CArDD;;AAsDAlD,OAAO,CAACwC,OAAR,GAAkBP,UAAlB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst config_1 = require(\"../config\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION });\n        }\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.COLLECTING_USER_INFORMATION });\n        }\n        case 'refresh_clear_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });\n        case 'refresh_set_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient }, state, dispatch) => {\n    const { refreshIntervalId, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useRefresh] ${message}`, obj);\n    /**\n     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n     * event, triggering the refreshFlow\n     */\n    const setRefreshPoll = (0, react_1.useCallback)((connectedWallet) => {\n        if (!refreshIntervalId) {\n            const interval = setInterval(() => {\n                dispatch({\n                    type: 'refresh_status_check',\n                    refreshIntervalId: interval,\n                    walletToRefresh: connectedWallet,\n                });\n            }, (0, config_1.getRefreshIntervalMs)(stage)); // this will be cleared on completion\n            // We need to know that the interval was set even if it has not fired yet.\n            // to avoid setting duplicate intervals.\n            dispatch({\n                type: 'refresh_set_interval',\n                refreshIntervalId: interval,\n            });\n            logger_1.default.debug('setRefreshPoll setInterval', (0, config_1.getRefreshIntervalMs)(stage));\n        }\n    }, [refreshIntervalId, stage]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshTokenWithProof = (0, react_1.useCallback)((useWallet) => ({ proof, payload }) => {\n        return new Promise((resolve, reject) => {\n            logDebug('Refresh token with proof', proof);\n            if (proof && gatewayToken) {\n                dispatch({ type: 'refresh_with_powo_in_progress' });\n                gatekeeperClient()\n                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload)\n                    .then(() => {\n                    resolve();\n                })\n                    .catch((error) => {\n                    logError('Error refreshing token with proof', error);\n                    reject(error);\n                });\n            }\n        });\n    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n    return {\n        setRefreshPoll,\n        refreshTokenWithProof,\n    };\n};\nexports.default = useRefresh;\n"]},"metadata":{},"sourceType":"script"}